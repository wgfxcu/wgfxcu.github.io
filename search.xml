<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Linux服务器性能检测-CPU负载篇]]></title>
      <url>%2F2016%2F12%2F30%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B-CPU%E8%B4%9F%E8%BD%BD%E7%AF%87%2F</url>
      <content type="text"><![CDATA[查看系统负载查看系统负载的工具: uptime、w 等。系统平均负载时处于运行或不可打扰状态的进程的平均数 * 可运行: 运行态，占用CPU，或就绪态，等待CPU调度 * 不可打扰: 阻塞，正在等待I/O 例1. 使用uptime查看系统负载 # uptime 19:26:17 up 49 days, 7:34, 1 user, load average: 0.67, 0.51, 0.41 这里我们关注的是最后三列，即系统1分钟、5分钟、15分钟内的平均负载，判断一个系统负载是否偏高需要计算单核CPU的平均负载，等于这里uptime命令显示的系统平均负载 / CPU核数，一般以0.7为比较合适的值。偏高说明有比较多的进程在等待使用CPU资源。 例2. 使用w查看系统负载 # w 19:29:47 up 49 days, 7:38, 1 user, load average: 0.42, 0.46, 0.41 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT openstac pts/1 10.14.16.25 19:21 1.00s 0.19s 0.03s sshd: openstack [priv] 使用 w 命令也可以查看类似的信息，w 命令还提供了当前登录用户，以及正在执行的操作等信息。系统负载可以是CPU密集型的，也可以是RAM密集型和I/O密集型的，CPU密集型的系统比I/O密集型的系统响应度更好，因为I/O密集型的系统的磁盘I/O可能完全饱和，导致登录就很费事。 top 命令top命令不仅可以查看当前系统的平均负载，还可以查看不同进程对于CPU、内存等资源的使用情况，在内存排障部分我们也将介绍top命令。例3.使用top命令查看CPU使用率 默认情况下，top命令是以CPU使用率由高到低排序显示进程信息的，在 top 信息界面按 K 键，并输入想要终止的PID，就可以直接杀死指定进程。 top的 -b 选项开启批处理模式，将每次刷新全部打印到stdouttop的 -n 选项指定退出top命令前刷新多少次信息。top命令的输出： 第1行：与uptime相同； 第3行：当前的CPU运行情况： us：非nice用户进程占用CPU的比率 sy：内核、内核进程占用CPU的比率； ni：如果一些用户进程修改过优先级，这里显示这些进程占用CPU时间的比率； id：CPU空闲比率，如果系统缓慢而这个值很高，说明系统慢的原因不是CPU负载高； wa：CPU等待执行I/O操作的时间比率，该指标可以用来排查磁盘I/O的问题，通常结合wa和id判断 hi：CPU处理硬件终端所占时间的比率； si：CPU处理软件终端所占时间的比率； st：流逝的时间，虚拟机中的其他任务所占CPU时间的比率； 用户进程占比高，wa低，说明系统缓慢的原因在于进程占用大量CPU，通常还会伴有教低的id，说明CPU空转时间很少； wa低，id高，可以排除CPU资源瓶颈的可能。 wa高，说明I/O占用了大量的CPU时间，需要检查交换空间的使用，交换空间位于磁盘上，性能远低于内存，当内存耗尽开始使用交换空间时，将会给性能带来严重影响，所以对于性能要求较高的服务器，一般建议关闭交换空间。另一方面，如果内存充足，但wa很高，说明需要检查哪个进程占用了大量的I/O资源。 iostat 命令iostat 命令可以查看系统分区的IO使用情况例4.iostat命令查看IO占用 1 wgfxcu@Ubos:~$ iostat 2 Linux 3.13.0-24-generic (Ubos) 2016年12月30日 _x86_64_ (1 CPU) 3 4 avg-cpu: %user %nice %system %iowait %steal %idle 5 0.22 0.01 0.55 0.04 0.00 99.17 6 Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn 7 scd0 0.00 0.00 0.00 48 0 8 sda 0.32 2.67 4.12 765668 1182218 9 dm-0 0.54 2.66 4.12 762573 1182212 10 dm-1 0.00 0.00 0.00 896 0 在第2行系统发行版本下面的第4、5行，可以看到与top命令中CPU使用情况类似的信息，第7行，可以看到一些IO指标： tps: 每秒I/O传输请求量； kB_read/s：每秒读取多少KB； kB_wrtn/s：每秒写多少KB； kB_read：一共读了多少KB； kB_wrtn：一共写了多少KB。 iostat命令属于sysstat工具包，由于我们的机器只挂载了一块硬盘，因此不能体现不同设备的I/O区别。 iotop 命令iotop命令类似于top命令，但是现实的是各个进程的I/O情况，对于定位I/O操作较重的进程有比较大的作用。例5. iotop命令与进程的IO状况 sysstat工具与负载历史回放很多系统负载过高的时候我们是无法立即获知或者立即解决的，当检测到或者知道历史的高负载状况时，可能需要回放历史监控数据，这时 sar 命令就派上用场了，sar命令同样来自sysstat工具包，可以记录系统的CPU负载、I/O状况和内存使用记录，便于历史数据的回放。Ubuntu系统上，sysstat的配置文件在/etc/default/sysstat，sysstat默认关闭，通过将该文件中的ENABLED改为”true”启用；历史日志的存放位置为/var/log/sysstatRed Hat系统上，sysstat的配置文件在/etc/sysconfig/sysstat文件，历史日志的存放位置为/var/log/sa两种系统上，统计信息都是每10分钟记录一次，每天的23:59会分割统计文件，这些操作的频率都在/etc/cron.d/sysstat文件配置。 sar命令查看CPU、内存和磁盘记录默认情况下，sar命令显示当天的统计信息，不带参数显示CPU统计信息，参数-r显示收集的内存记录，-b显示磁盘I/O例6. 使用sar命令查看CPU使用 # sar Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 12:00:01 AM CPU %user %nice %system %iowait %steal %idle 12:05:01 AM all 3.83 0.02 4.24 0.61 0.00 91.30 12:15:01 AM all 3.57 0.02 4.28 0.58 0.00 91.54 12:25:01 AM all 3.83 0.02 5.16 0.60 0.00 90.39 12:35:01 AM all 3.98 0.02 5.66 0.58 0.00 89.76 12:45:01 AM all 3.86 0.02 5.26 0.59 0.00 90.28 12:55:01 AM all 3.77 0.02 5.19 0.60 0.00 90.42 例7. 使用sar命令查看当天内存使用 # sar -r Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 12:00:01 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 12:05:01 AM 6420736 5839392 47.63 242640 1366912 6811944 55.56 4324000 1202152 24 12:15:01 AM 6423128 5837000 47.61 242640 1367348 6830944 55.72 4320608 1202400 48 12:25:01 AM 6430984 5829144 47.55 242640 1367548 6814980 55.59 4314376 1202468 48 12:35:01 AM 6422924 5837204 47.61 242640 1367848 6817224 55.60 4321604 1202576 48 12:45:01 AM 6427300 5832828 47.58 242640 1368056 6822240 55.65 4318412 1202572 28 例8. 使用sar命令查看当天IO统计记录 # sar -b Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 12:00:01 AM tps rtps wtps bread/s bwrtn/s 12:05:01 AM 7.44 0.00 7.44 0.00 279.22 12:15:01 AM 6.45 0.00 6.45 0.00 255.84 12:25:01 AM 6.59 0.00 6.59 0.00 260.20 12:35:01 AM 6.51 0.00 6.51 0.00 261.42 12:45:01 AM 6.42 0.00 6.42 0.00 255.79 使用sar查看指定时间、制定日期的历史记录例9. 使用参数-s和-e先定查看的时间 # sar -s 20:00:00 Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 08:05:01 PM CPU %user %nice %system %iowait %steal %idle 08:15:01 PM all 3.98 0.02 6.07 0.58 0.00 89.34 08:25:01 PM all 4.32 0.02 5.74 0.58 0.00 89.34 Average: all 4.15 0.02 5.91 0.58 0.00 89.34 例10. 使用参数-f查看本月内之前某一天的历史统计信息 # sar -f /var/log/sysstat/sa08 Linux 3.13.0-55-generic (ISeR-Server1) 08/08/2015 _x86_64_ (4 CPU) 12:00:01 AM CPU %user %nice %system %iowait %steal %idle 12:05:01 AM all 3.65 0.02 2.79 0.60 0.00 92.94 12:15:01 AM all 3.45 0.02 3.03 0.56 0.00 92.94 12:25:01 AM all 3.43 0.02 3.25 0.56 0.00 92.74 12:35:01 AM all 3.44 0.01 3.09 0.56 0.00 92.89 12:45:01 AM all 3.25 0.02 1.35 0.55 0.00 94.83 12:55:01 AM all 3.36 0.02 1.77 0.56 0.00 94.29 sysstat工具只存储1个月内的系统使用记录，每天的记录以saN为文件名保存在相应的日志目录中，这里我们查看本月8号的CPU使用记录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux服务器性能检测-内存篇]]></title>
      <url>%2F2016%2F12%2F30%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B-%E5%86%85%E5%AD%98%E7%AF%87%2F</url>
      <content type="text"><![CDATA[事实上，当上述服务器系统资源中的任何一个遭遇瓶颈，都会带来服务器性能的下降，典型的症状就是系统运行迟缓。本文从以下几个角度介绍Linux系统内存相关的排查。 内存的使用率如何查看，使用率真的很高吗 内存用在哪里了 内存优化可以有哪些手段 内存硬件查看在Linux系统环境下，可以使用dmidecode命令查看硬件设备的详细信息。命令格式: dmidecode -t typecode其中typecode是设备类型代码， 具体代码如下： 0 BIOS 1 System 2 Base Board 3 Chassis 4 Processor 5 Memory Controller 6 Memory Module 7 Cache 8 Port Connector 9 System Slots 10 On Board Devices 11 OEM Strings 12 System Configuration Options 13 BIOS Language 14 Group Associations 15 System Event Log 16 Physical Memory Array 17 Memory Device 18 32-bit Memory Error 19 Memory Array Mapped Address 20 Memory Device Mapped Address 21 Built-in Pointing Device 22 Portable Battery 23 System Reset 24 Hardware Security 25 System Power Controls 26 Voltage Probe 27 Cooling Device 28 Temperature Probe 29 Electrical Current Probe 30 Out-of-band Remote Access 31 Boot Integrity Services 32 System Boot 33 64-bit Memory Error 34 Management Device 35 Management Device Component 36 Management Device Threshold Data 37 Memory Channel 38 IPMI Device 39 Power Supply 例如： 使用dmidecode -t 1 可以查看主板信息(制造商、型号、序列号等等) 使用dmidecode -t 4 可以查看CPU信息(CPU数据、型号、大小、频率等等) 使用dmidecode -t 17 可以查看内存信息(插槽数目、内存类型、大小、频率等等) 通过dmidecode工具可以查看很多硬件相关的数据，这里仅以内存为例。我们可以看到，服务器最大支持内存扩充为4GB，目前已经安装了4GB内存。 内存的使用情况使用free命令可以查看内存的使用情况。-m以MB为单位显示整个系统的使用情况: -h则自动选择以适合理解的容量单位显示: 可以看到系统内存4G(总可用3.9G)，当前医用3.8G，剩余103M。命令显示的”used”的值很高，接近total的值了，那么系统就真的没有内存空间了吗？我们可以看到free命令下面有一行“-/+ buffers/cache”，该行显示的used是上一行“used”的值减去buffers和cached的值，同时该行的free是上一行的free加上buffers和cached的值。这里可以看到，尽管第一行的used显示共使用了3.8GB的物理内存，但除去buffers和cached数据后，实际仅仅占用了631M的内存，而如果剩余空间加上buffers和cached数据当前占用的内存，将达到3.2BG。这是因为buffers和cache数据是动态变化的，内存充足时，内核出于性能考虑会进行一定的缓存，当内存空间不足时，buffers, cached占用的空间是可以为了程序释放的。因此判断系统内存是否耗竭的实际指标是看减去buffer和cache的空间后used空间是否依旧很大，以及交换空间是否被大量占用。显然这个例子不符合内存耗竭的情形。 查看消耗内存较多的内存top 命令用来查看具体进程消耗的内存空间 top 命令查看系统的实时负载，包括进程、CPU负载、内存使用等等；进入top的实时界面后，默认按照CPU的使用率排序，通过”shift+m”将进程按照内存使用情况排序，可以查看哪些进程是当前系统的内存开销”大户”。top 命令中，按下f键，进入选择排序的界面，可以选择要显示的信息列，要按照哪些信息列进行排序等，该界面上有简要的介绍。另一方面，我们查看不同进程的内存开销: 通过%MEM列，可以查看哪几个进程占用了大量的内存，在缓解内存不足的紧急情况时，可以终止这些占用内存较多的进程。top 命令中有一下与内存相关的数据列: （1）VIRT:虚拟内存，是进程身亲的虚拟内存总量。 （2）RES: 常驻内存，是进程切实使用的物理内存量，free命令中看到的used列下面的值，就包括常驻内存的和，但不是虚拟内存的和。 （3）SHR: 共享内存，比如共享占用的内存等。 交换空间使用free 命令可以查看内存的总体使用，显示的内容也包括交换分区的大小，使用swapon、swapoff命令开启或关闭交换空间，交换空间是磁盘上的文件，并不是真正的内存空间。当内存不足时，系统会选择通过: 1.将部分不常被访问的内存页交换到内存空间; 2.删除部分cache 的文件来释放内存空间。系统的可用内存一般等于物理内存+交换分区。交换分区在磁盘上，因此速度比内存读写要慢的多。交换分区实际上就是磁盘上的文件，可以通过mkswap 命令创建交换空间。 内核态内存占用slab系统用来处理系统中比较小的元数据，如文件描述符等，进而组织内核态的内存分配。一个slab包含多个object,例如dentry这些数据结构就是object,可以通过slabtop命令查看系统中活动的object的数量与内存占用情况，从而了解哪些数据结构最占用内核态的内存空间。例如: 使用slabtop 命令查看内核数据结构及内存占用 关注点: 1. 哪些数据结构的内存占用最大 2. 哪些类型的数据结构对应的object最多，比如inode多代表文件系统被大量引用等。 该交互命令支持的选项与排序标准有:选项： --delay=n, -d n 每隔n秒刷新信息 --once, -o 只显示一次 --sort=S, -s S 按照S排序，其中S为排序标准 排序标准(shift + 对应的键)： a：根据active objects数量高低排序 b：根据 objects / slab高低来排序 c：根据cache大小排序 l：根据slab数量排序 v：根据active slabs数量排序 n：按 name 排序 o：按照 objects 数量排序 p：按照 pages / slab 的值排序 s：按照 object 大小排序 u：按照 cache 使用量排序 查看内存使用的动态变化vmstat命令可以查看内存使用的动态变化 每行会输出一些系统核心指标，这些指标可以让我们更详细的了解系统状态。后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义，这几介绍一些和性能调优相关的列： r：等待CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。 free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。 si, so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。 us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。 dstatdstat命令是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具。与sysstat相比，dstat拥有一个彩色的界面，在手动观察性能状况时，数据比较显眼容易观察；而且dstat支持即时刷新，譬如输入dstat 3即每三秒收集一次，但最新的数据都会每秒刷新显示。和sysstat相同的是，dstat也可以收集指定的性能资源，譬如dstat -c即显示CPU的使用情况。 查看共享内存空间pmap 命令用于报告进程的内存映射关系，是Linux调试及运维一个很好的工具。常用选项: -x: 显示扩展格式 -d: 显示设备格式 -q: 不显示头尾行 -V: 显示指定版本 参数: 进程号: 制定需要显示内存映射关系的进程号，可以是多个进程号 查看系统内存历史记录sar(System Activity Reporter系统活动情况报告) 是目前Linux上最为全面的系统性能分析工具之一。可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。命令格式: sar [options] [-A] [-o file] t [n] 其中: t 为采样间隔，n为采样次数，默认值是1 -o file 表示将命令结果以二进制格式存放在文件中，file是文件名 options 为命令行选项，命令常用选项: -A: 所有报告的总和 -u: 输出CPU使用情况的统计信息 -v: 输出inode、文件和其他内核表的统计信息 -d: 输出每一块设备的活动信息 -r: 输出内存和交换空间的统计信息 -b: 显示I/O和传送速率的统计信息 -a: 文件读写情况 -c: 输出进程统计信息,每秒创建的进程数 -R: 输出内存页面的统计信息 -y: 终端设备活动情况 -w: 输出系统交换活动信息 如何清理内存使用 释放占用的缓存空间 # sync //先将内存刷出，避免数据丢失 # echo 1 &gt; /proc/sys/vm/drop_caches //释放pagecache # echo 2 &gt; /proc/sys/vm/drop_caches //释放dentry和inode # echo 3 &gt; /proc/sys/vm/drop_caches //释放pagecache、dentry和inode 终止进程 与Linux内存相关的文件系统文件内存信息: /proc/meminfo进程状态信息: /proc/$pid/status进程物理内存信息: /proc/$pid/statmslab的分布情况: /proc/slabinfo虚拟内存信息: /proc/vmstat 小福利 降低swap的使用率: # sysctl -a | grep swappiness vm.swappiness = 60 限制其他用户的内存使用: # vim /etc/security/limits.conf user1 hard as 1000 （用户user1所有累加起来，内存不超过1000kiB） user1 soft as 800 （用户user1一次运行，内存不超过800kiB） 大量连续内存数据: # vim /etc/sysctl.conf vm.nr_hugepage=20 调节page cache(大量一样的请求 调大page cache) vm.lowmem_reserve_ratio = 256 256 32 （保留多少内存作为pagecache 当前 最大 最小） vm.vfs_cache_pressure=100 （大于100，回收pagecache） vm.page.cluster=3（一次性从swap写入内存的量为2的3次方页） vm.zone_reclaim_mode=0/1（当内存危机时，是否尽量回收内存 0:尽量回收 1:尽量不回收） min_free_kbytes：该文件表示强制Linux VM最低保留多少空闲内存（Kbytes）。 脏页 vm.dirty_background_radio=10 （当脏页占内存10%，pdflush工作） vm.dirty_radio=40 （当进程自身脏页占内存40%，进程自己处理脏页，将其写入磁盘） vm.dirty_expire_centisecs=3000 （脏页老化时间为30秒 3000/100=30秒） vm.dirty_writeback_centisecs=500 （每隔5秒，pdflush监控一次内存数量 500/100=5秒）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建GitHub博客（三）- NexT主题配置使用]]></title>
      <url>%2F2016%2F12%2F07%2FNexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[NexT是一款简洁优雅且易于使用的主题，配置比较简单，只需要稍微修改配置文件即可，功能也比较全，分类、归档、标签显示明了，让人一看就知道干嘛的。 NexT主题官方文档还算详细，但是有些部分的介绍不够详细，这里我做部分补充，并对自己做了修改的部分作介绍。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 安装 NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码 $ cd your-hexo-site $ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 设置 菜单NexT主题菜单设置，用于设置博客上方导航栏，在 主题配置文件 中修改。 menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 只是在menu选项中设置还不能让标签页面、分类页面生效，需要我们手动创建 标签页面1&gt;运行以下命令 hexo new page &quot;tags&quot; 同时，在/source目录下会生成一个tags文件夹，里面包含一个index.md文件 2&gt;修改/source/tags目录下的index.md文件 title: tags date: 2015-09-29 14:37:02 type: &quot;tags&quot; --- 3&gt;修改主题配置文件去掉tags的注释 menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 分类页面1&gt;运行以下命令 hexo new page &quot;categories&quot; 同时，在/source目录下会生成一个categories文件夹，里面包含一个index.md文件 2&gt;修改/source/categories目录下的index.md文件 title: categories date: 2015-09-29 14:47:21 type: &quot;categories&quot; --- 3&gt;修改主题配置文件去掉categories的注释 menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 设置侧栏默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值 设置侧栏显示的时机，修改 sidebar.display 的值 侧边头像设置在next主题文件夹中的 source 目录中，创建 uploads 目录，将你的头像avatar.png放入该目录下。编辑 站点配置文件，增加avatar字段 # Avatar avatar: /uploads/avatar.png 设置作者昵称编辑 站点配置文件， 设置 author 为你的昵称。 站点描述编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 多说评论多说站点使用多说前需要先在 多说 创建一个站点。具体步骤如下： 登录后在首页选择 “我要安装”。 创建站点，填写站点相关信息。 多说域名 这一栏填写的即是你的 duoshuo_shortname，如图： 创建站点完成后在 主题配置文件 中duoshuo_shortname 字段的值设置成上一步中的值。 12# Duoshuo ShortName duoshuo_shortname: wgfxcu 至此，当你重新访问你的博客时，在每篇博文后面就会有多说的评论框。但是，你会发现在分类页和标签页也会看到评论框，如果你感觉不爽可以通过下面的方法去掉。 去除分类页标签页多说评论修改站点的/source/categories/目录下的 index.md 文件 --- title: categories date: 2016-12-06 15:58:52 type: &quot;categories&quot; comments: false #去除多说评论框 --- 同样修改站点的/source/tags/目录下的index.md文件即可去掉标签页的评论框. 数据统计与分析官方提供的 数据统计与分析 配置了一下，感觉影响主题的整体美观，所以放弃了。如果有需要可以参考官网文档设置一下。 内容分享服务官方提供的 内容分享服务 配置了一下，感觉影响主题的整体美观，所以放弃了。如果有需要可以参考官网文档设置一下。 搜索服务官方提供的 搜索服务 有兴趣的可以折腾一下。 至此，我们的博客就搭建完成了。O(∩_∩)O哈哈~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建GitHub博客（二）- Hexo配置使用]]></title>
      <url>%2F2016%2F12%2F07%2FHexo%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[这篇博文主要介绍Hexo的配置安装和Hexo的常用命令，还有如何部署博客到GitHub。 Hexo 安装打开Git命令行，执行如下命令 $ npm install -g hexo 初始化博客安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init blog$ cd blog$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml1网站的配置信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 123456789101112131415161718192021222324package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.2.2&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-searchdb&quot;: &quot;^1.0.3&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-migrator-rss&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot;, &quot;hexo-toc&quot;: &quot;^1.0.4&quot; &#125;&#125; scaffolds模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题文件夹。Hexo 会根据主题来生成静态页面。 配置您可以在 _config.yml 中修改大部份的配置。 网站 网址 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 文章 分类 &amp; 标签 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 分页 扩展 Hexo 指令init$ hexo init [folder] 新建一个网站。如果没有设置 folder，Hexo 默认在目前的文件夹建立网站。 new$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate$ hexo generate 生成静态文件。 publish$ hexo publish [layout] &lt;filename&gt; 发表草稿。 server$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 deploy$ hexo deploy 部署网站。 render$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 migrate$ hexo migrate &lt;type&gt; 从其他博客系统迁移内容。 clean$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 list$ hexo list &lt;type&gt; 列出网站资料。 version$ hexo version 显示 Hexo 版本。 选项安全模式$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式$ hexo --silent 隐藏终端信息。 自定义配置文件的路径$ hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 测试启动Server运行以下命令 $ hexo server Hexo server启动后，在浏览器中打开http://localhost:4000/ 即可访问自己的博客，按Ctrl+C停止 创建文章运行以下命令，可生成一篇文章，刷新http://localhost:4000/ 即可看到新生成的文章。 $ hexo new &quot;hello-hexo&quot; 同时在/blog/source/_posts目录下会生成一个”hello-hexo.md”的markdown文件，可以使用一个支持markdown语法的编辑器来编辑该文件，刷新http://localhost:4000/ 即可看到修改后的结果。 打开这个文件 生成静态网页运行以下命令，将markdown文件生成静态网页。 $ hexo generate 同时在/blog/目录下会生成一个public文件夹，里面是生成的静态文件。 部署到GitHub至此我们已经可以在本地访问自己的博客了，但是只有本地能够看到，要部署到GitHub上面别人才能看到。我们可以在本地调试编辑好文章后再推送到GitHub上面。下面是部署到GitHub的过程。 创建github page在第一篇文章中我们已经在自己的github中创建了自己的github page。参考Hexo搭建GitHub博客（一）- 环境搭建 安装自动部署到GitHub的插件在初始化博客的时候运行的npm install命令默认并没有安装这个插件，所以要手动安装。运行以下命令 $ npm install hexo-deployer-git 修改站点配置文件 修改位于 blog 目录下的 _config.yml 文件找到以下内容 repository是自己github page的项目地址 运行hexo deploy命令运行以下命令 $ hexo deploy 过程中会提示输入你的github账号和密码，等待命令运行完成即可。部署完成后，在浏览器中访问wgfxcu.github.io能够看到你在本地调试好的博客，表示部署成功！ 部署步骤总结至此，部署到GitHub的工作已经完成，之后如果我们希望对自己的博客进行修改或者需要发布新的文章时，可以按以下三步进行。123$ hexo clean # 删除已经生成的静态页面 $ hexo generate $ hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建GitHub博客（一）- 环境搭建]]></title>
      <url>%2F2016%2F12%2F05%2FHexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[前言之前无意中发现conglang的github博客，简洁干净，符合我的style。后来发现他使用HEXO+GitHub+Next主题搭建的。按耐不住就索性自己也来一个。同时也记录一下自己的实现过程，做个备案。 推荐理由: 免费：github提供gh-pages服务是免费的，有300MB空间； 开源：由于github开源的原因，有很多人参与其中，自然技术支持很好。 便捷：博客完全托管在github上，基本上不需要花时间去管理，博客使用Markdown语法，上手很容易。 需要了解的内容（能掌握更好）： html+css+javascript git基本语法 markdown语法 nodejs 说明：本次搭建的环境是：Ubuntu14.04 安装 Git安装 Git 客户端 安装 Git 客户端 下载地址 安装Git客户端：Windows用户直接Next就可以了。Mac和Linxu系统的用户可通过命令方式安装，这里不详细介绍了。 附上廖雪峰的Git经典入门教程: Git入门教程 注册 GitHub 老手和已注册过的用户略 打开GitHub官网：https://github.com/ 填写注册信息进行注册操作：没有登录的用户打开网站首页就会显示注册的操作（如图所示），或者是点击Sign up按钮进入注册详情页。 填写好注册信息，点击Sign up for GitHub(注册)按钮后，接下来是选择协议部分。根据自己的情况选择相关的协议，一般人选的都是免费的那一项。 创建仓库 登录github账号：在github首页点击Sign in按钮进入登录页面。填写用户名或邮箱和密码，点击Sign in按钮登录。 点击创建仓库：点击在登录的用户图像左边的+号和下三角符号按钮。 填写创建仓库信息：仓库名称必须是用户名.github.io（别问我为什么，人家就是这样规定的），比如我的用户名是wgfxcu，就是wgfxcu.github.io。 填写好相关信息，点击Create repository(创建仓库)按钮。 配置 SSH 老手和已注册过的用户略 打开Git Bash终端：在桌面右键，会出现”Git Bash here”的选项，点击即可。 设置user name和email： $ git config --global user.name &quot;你的GitHub用户名&quot; $ git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥:输入下面命令 $ ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 一般情况下是不需要密码的，所以，接下来直接回车就好。 此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。 注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件. 添加公钥到github： 点击用户头像，然后点击显示的Settings(设置)选项； 在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key(新建SSH)按钮； 将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮； 测试 SSH: $ ssh -T git@github.com 接下来会出来下面的确认信息： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 17:24:ac:a5:76:28:24:36:62:1b:36:4d:eb:df:a6:45. Are you sure you want to continue connecting (yeso)? 输入yes后回车。 然后显示如下信息则OK(其中的SeayXu是用户名)。 Hi wgfxcu! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 搭建 Node.js 开发环境本次没有使用ubuntu自带的nodejs版本，实在是版本太低。也没有使用源码进行安装，实在是太麻烦。根据Hexo官方文档使用nvm管理和安装Node.js。nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。 安装 nvmcURL: $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 脚本下载nvm仓库下载到 ~/.nvm , 同时在你的配置文件中添加源代码行 (~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc)。 export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 如果你在shell命令行中输入nvm，得到的是 nvm: command not found。你需要在命令行中执行以下命令： source ~/.bashrc 安装切换各版本 node/npmnvm install stable #安装最新稳定版 node，现在是 v7.2.0 nvm install 6.0.0 #安装 6.0.0 版本 nvm install 0.12.7 #安装 0.12.7 版本 # 特别说明：以下模块安装仅供演示说明，并非必须安装模块 nvm use 0 #切换至 0.12.7 版本 nvm use 6 #切换至 6.0.0 版本 nvm alias default 7.2.0 #设置默认 node 版本为 7.2.0 这时候可以看到自己安装的所有 Node.js 版本，输出应如下： 使用 .nvmrc 文件配置项目所使用的 node 版本如果你的默认 node 版本（通过 nvm alias 命令设置的）与项目所需的版本不同，则可在项目根目录或其任意父级目录中创建 .nvmrc 文件，在文件中指定使用的 node 版本号，例如： cd &lt;项目根目录&gt; #进入项目根目录 echo 7 &gt; .nvmrc #添加 .nvmrc 文件 nvm use #无需指定版本号，会自动使用 .nvmrc 文件中配置的版本 node -v #查看 node 是否切换为对应版本 nvm 与 n 的区别node 版本管理工具还有一个是 TJ 大神的 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。 由于 npm 安装的模块路径均为 /usr/local/lib/node_modules ，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。 因此建议各位尽早开始使用 nvm ，以免出现全局模块无法更新的问题。关于 nvm 和 n 详细区别可以参考淘宝前端团队(FED)博客。 ###]]></content>
    </entry>

    
  
  
</search>
