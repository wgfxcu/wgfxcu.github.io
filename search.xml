<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Linux服务器性能检测-网络篇]]></title>
      <url>%2F2017%2F01%2F03%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B-%E7%BD%91%E7%BB%9C%E7%AF%87%2F</url>
      <content type="text"><![CDATA[用于排查Linux系统的网络故障。网络排查一般是有一定的思路和顺序的，其它排查的思路就是根据具体的问题逐段排除故障可能发生的地方，最终确定问题。所以首先要问一问，网络问题是什么，是不通，还是慢？ 如果是网络不通，要定位具体的问题，一般是不断尝试排除不可能故障的地方，最终定位问题根源。一般需要查看 是否接入到链路 是否启用了相应的网卡 本地网络是否连接 DNS故障 是否路由到目标主机 远程端口是否开放 如果网络速度慢，一般有以下几个方式定位问题源: DNS是否有问题 查看路由过程中哪些节点是瓶颈 查看带宽的使用情况 网络不通一般来说当存在网络不通的故障时，访问出端和入端的信息是我们都要收集的，目的在于确定问题所在的主机或者区段。假如a不能访问c而b能访问c，那么很明显问题出在a或a到c的网络上，而通过同一子网中的几台机器a、b可以正常访问网络，却不能访问c，那么可能是这个网络到c存在问题，或c存在问题。定位了问题所在的主机，一般有一下步骤来逐渐缩小问题范围，最终定位问题: 链路是否连通 即检查网络与网络是否物理连通，网线是否插好且连接可用，很多时候不能立刻到机房确定物理连接，可以用命令: # ethtool ethN ethN是连接到故障网络的网卡 例1. 使用ethtool查看eth0的物理连接 # ethtool eth0 Settings for eth0: Supported ports: [ TP ] Supported link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Supported pause frame use: No Supports auto-negotiation: Yes Advertised link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Advertised pause frame use: No Advertised auto-negotiation: Yes Speed: 1000Mb/s Duplex: Full Port: Twisted Pair PHYAD: 1 Transceiver: internal Auto-negotiation: on MDI-X: Unknown Supports Wake-on: g Wake-on: g Link detected: yes 其中，14行显示了当前网卡的速度，这是一个千兆网卡；15行显示了当前网络支持全双工；23行显示当前网卡和网络的物理连接正常。通常网速和全/半双工状态是主机和网络协议商自动协商的，例如这里第8行的auto-negotiation。如果发现15行的双工被设置成Half,可以手动将其改为全双工网络: # ethtool -s eth0 autoneg off duplex full 网卡是否正常启用 一般网络物理连接故障的情况并不多见，当排除物理连接上的问题后，需要进一步查看网卡的工作状态。 例2. 使用ifconfig命令查看网卡eth1状态 # ifconfig eth1 eth1 Link encap:Ethernet HWaddr e4:1f:13:b5:b0:62 inet addr:10.0.0.11 Bcast:10.0.0.255 Mask:255.255.255.0 inet6 addr: fe80::e61f:13ff:feb5:b062/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:74282478 errors:0 dropped:0 overruns:0 frame:0 TX packets:77425890 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:13948947045 (13.9 GB) TX bytes:51073249506 (51.0 GB) 第3行的信息显示了对该网卡的配置，包括IP，子网掩码等，这里可以检查是否出现错配，如果这一行显示不正确，那一定是网卡没有正确配置开启。 基于Debian的Linux的(永久)网络配置文件在”etc/network/interfaces” 基于Red Hat的Linux的(永久)网络配置文件在”/etc/sysconfig/network_scripts/ifcfg-“ 是否正确设置网关 如果网卡已经正常启动，需要确认目标网络接口是否正确配置网关，同时主机和网关之间的连接没有问题，通过route命令和ping命令结合完成这一极端的排查。 例3. 使用route命令查看内核路由表 # route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 101.111.123.1 0.0.0.0 UG 0 0 0 eth0 10.0.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1 101.111.123.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 route -n以IP而不是主机名的形式显示网关等信息，一方面更快，另一方面不涉及DNS，通过route命令查看内核路由，检验具体的网卡是否连接到目标网络的路由，之后就可以尝试ping网关，排查与网关之间的连接。 如果无法ping通网关，可能是网关限制了ICMP数据包，或者交换机设置的问题。 DNS工作状况 通常很多网络问题是DNS故障或者配置不当造成的，nslookup和dig命令能够用来排查DNS问题 例4.使用nslookup命令查看DNS解析 # nslookup baidu.com Server: 10.21.1.205 Address: 10.21.1.205#53 Non-authoritative answer: Name: baidu.com Address: 220.181.57.217 Name: baidu.com Address: 123.125.114.144 Name: baidu.com Address: 180.149.132.47 这里的DNS服务器10.21.1.205位于当前局域网内，nslookup的结果显示DNS工作正常。如果遇到nslookup命令无法解析目标域名，则很可能是DNS配置不当，到/etc/resolv.conf文件中查看是否存在域名服务器的配置: # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8) # DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN nameserver 10.21.1.205 /etc/resolv.conf文件是临时即刻生效的DNS服务器配置，想要永久配置DNS服务器的地址，可以在/etc/networks/interfaces（基于Debian）中通过 “dns-nameservers” 字段来限制： 例6. 永久生效的DNS配置–/etc/networks/interfaces文件 auto lo iface lo inet loopback auto eth0 iface eth0 inet static network ... netmask 255.255.255.0 broadcast ... gateway ... address ... dns-nameservers 10.21.1.205 如果我们的DNS服务器在一个子网内，而无法ping通它，这个DNS服务器很可能已经宕机。 是否可以正常路由到远程主机 互联网是通过大量路由器中继连接起来的，网络的访问就是这些节点间一跳一跳最终到达目的地，想要查看网络连接，最直接最常用的命令是ping,ping得通，说明路由工作正常，如果ping不通，traceroute命令可以查看当前主机到目标主机的全部”跳”的过程。 traceroute和ping命令都是使用ICMP协议包。 例7. 使用traceroute追踪路由状况 # traceroute www.baidu.com traceroute to www.baidu.com (220.181.111.188), 30 hops max, 60 byte packets 1 123.123.123.1 (123.123.123.1) 1.844 ms 1.847 ms 2.102 ms 2 1.1.1.6 (1.1.1.6) 0.389 ms 0.393 ms 0.542 ms 3 localhost (10.1.150.1) 2.556 ms 3.730 ms 3.155 ms 4 localhost (10.12.16.17) 1.214 ms 1.190 ms 1.196 ms 5 localhost (10.12.30.105) 1.533 ms 1.541 ms localhost (10.12.30.101) 1.692 ms 6 202.112.41.37 (202.112.41.37) 3.350 ms 2.998 ms 2.977 ms 7 101.4.112.94 (101.4.112.94) 4.631 ms 101.4.117.82 (101.4.117.82) 3.846 ms 101.4.112.94 (101.4.112.94) 3.808 ms 8 101.4.112.89 (101.4.112.89) 3.120 ms 2.844 ms 2.857 ms 9 101.4.115.9 (101.4.115.9) 5.957 ms 5.912 ms 4.741 ms 10 101.4.117.110 (101.4.117.110) 2.080 ms 2.070 ms 2.036 ms 11 202.97.88.229 (202.97.88.229) 35.257 ms 202.97.57.45 (202.97.57.45) 35.373 ms 202.97.57.49 (202.97.57.49) 35.244 ms 12 * * * 13 * * * 14 * 220.181.17.18 (220.181.17.18) 35.869 ms 220.181.182.34 (220.181.182.34) 38.279 ms 15 * * * 16 * * * 17 * * * 18 * * * 19 * * * 20 * * * 21 * * * 22 * * * 23 * * * 24 * * * 25 * * * 26 * * * 27 * * * 28 * * * 29 * * * 30 * * * 查看第3行，第一跳到达了当前子网的网关，然后跳到了澳大利亚的亚太网络咨询中心（APNIC）等等，traceroute可以查看网络中继在哪里中断或者网络延时情况，“*”是因为网络不通或者某个网关限制了ICMP协议包。 远程主机是否开放端口 telnet命令是检查端口开放情况的利器，或者nmap工具 例8. 使用telnet检测 # telnet 220.181.111.188 80 Trying 220.181.111.188... Connected to 220.181.111.188. Escape character is &apos;^]&apos;. telnet IP PORT 可以查看指定远程主机是否开放目标端口，这里百度的前端服务器开放80端口是网页服务必须的。 但是telnet命令的功能非常有限，当防火墙存在时，就不能很好的显示结果，所有telnet无法连接包含两种可能:1.端口确实没有开放 2.防火墙过滤了连接。 例如：我们尝试telnet连接百度前端服务器的22端口: # telnet 220.181.111.188 22 Trying 220.181.111.188... telnet: Unable to connect to remote host: Connection timed out 无法继续进行，但是我们无法判断究竟是端口没有开放，还是被防火墙给拦截了，这时使用nmap工具将更加强大: 例9.使用nmap工具监测端口开放情况 # nmap -p 22 220.181.111.188 Starting Nmap 6.40 ( http://nmap.org ) at 2015-08-10 20:45 CST Nmap scan report for 220.181.111.188 Host is up (0.040s latency). PORT STATE SERVICE 22/tcp filtered ssh 同样的服务器，使用nmap检测，观察到第7行，说明实际上该服务器是启用了22端口的，但是防火墙过滤了数据包，如果端口真的没有启用，那么第7行的STATE将显示closed，而不是filtered。开放的端口其状态将是open。 这时就可以了解，端口无法连接的原因是端口关闭还是防火墙过滤了。 本机查看监听端口 如果要在本地查看某个端口是否开放，可以使用如下命令: # netstat -lnp | grep PORT 其中，参数： * -l 显示正在监听的套接字 * -p 显示套接字所属的进程ID和进程名 * -n 以数字形式显示地址 例10. 查看本地制定端口的监听情况 # netstat -lnp | grep :11211 Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 10.0.0.11:11211 0.0.0.0:* LISTEN 28911/memcached udp 0 0 10.0.0.11:11211 0.0.0.0:* 28911/memcached 例10以memcached服务为例，查看当前活动端口监听的网络，如果netstat找不到指定的端口，说明没有进程在监听指定端口。 其中第一列是套接字通信协议，第2列和第3列显示的是接收和发送队列，第4列是主机监听的本地地址，反应了该套接字监听的网络;第6列显示当前套接字的状态，最后一列显示打开端口的进程。 查看防火墙规则 使用iptables 命令查看当前主机的防火墙，iptables的功能在这里就不涉及，后续的博文会详细介绍 # iptables -L 网络较慢的排查网络较慢的排查事实上比网络不通的排查更有挑战，因为很多时候可能是运营商、DNS等的原因，这些故障尝尝不在我们的控制范围之内，只能手机证据向其反馈或其进行投诉。如果不想受到DNS的影响，上面提到的命令可以添加-n选项，-n选项可以阻止视图将IP解析为主机名，从而绕过DNS。 traceroute 前面提到的traceroute不仅可以查看路由的正确性，还可以查看网络中每一跳的延时，从而定位延时最高的网络区段。 iftop iftop命令类似于top命令，可以查看哪些网络连接占用的带宽较多 例11. 使用iftop命令查看连接占用的网络带宽 这里比较全地给出了一个iftop命令的实例，该命令按照带宽占用高低排序，可以确定哪些占用的带宽的网络连接。 最上方的一行刻度是整个网络的带宽比例，下面第1行是源IP，第2列是目标IP，剪头表示了二者之间是够在传输数据，以及传输的方向。最后三列分别是2s、10s、40s时两个主机之间的数据传输速率。 最下方的TX、RX分别代表发送、是接收数据的统计,TOTAL则是数据传输总量。 * 使用 -n 选项直接显示连接的IP，例11中看到的则是解析成域名后的结果。 * -i 选项可以指定要查看的网卡，默认情况下，iftop会显示自己找到的第一个网卡 * 在进入iftop的非交互界面后，按 p 键可以打开或关闭显示端口，按 s 键可以显示或隐藏源主机，而按 d 键则可以显示或隐藏目标主机 tcpdump 当一切排查手段都无济于事时仍然不能找到网络速度慢、丢包严重等原因时，往往祭出杀手锏——抓包。抓包的最佳手段是在通信的双方同时抓取，这样可以同时检验发出的数据包和收到的数据包，tcpdump是常用的抓包工具。 例12. tcpdump抓包示例 # tcpdump 23:47:43.326284 IP ISeR-Server1.ntp &gt; 183.60.211.47.9579: NTPv2, Reserved, length 440 23:47:43.326288 IP 58.221.64.43.27777 &gt; ISeR-Server1.ntp: NTPv2, Reserved, length 8 例12只是借去了抓包结果的两行作为示意，可以通过tcpdump查看通信的时间、双方的地址(-n 选项) 端口，通信的目的，数据包的长度等等。 当想要停止抓包时，使用ctrl-c终止抓包，tcpdump会返回所有抓取到的数据包的个数: 14422 packets captured 1127345 packets received by filter 1109698 packets dropped by kernel tcpdump有一些常用选项，便于记录，tcpdump的详细使用，这里就不介绍了，当然，图形界面用户还可以使用更为专业的分析工具WireShark。 # tcpdump -n port N //只捕捉特定端口的流量 # tcpdump -n port N1 or port N2 //捕获多个端口的流量 # tcpdump -w output.pcap //数据包转储，将原始数据包保留到output.pcap # tcpdump -C 10 -w output.pcap //限制每个转储文件的上限，达到上限后将文件分卷(以MB为单位) # tcpdump -C 10 -W 5 -w output.pcap //不仅限制每个卷的上限，而且限制卷的总数 # tcpdump -r output.pcap //重播已经保存的数据包记录 此外， 鸟哥的Linux私房菜中也提供了一些类似的网络排查思路： 1. 网卡是否工作，包括硬件和驱动：lspci，dmesg 2. IP参数是否正确设置：ifconfig 3. 局域网内通信是否正常：ping 4. 路由信息是否正常：route -n 5. DNS状态：dig, nslookup 6. 路由节点状况与延时：traceroute 7. 服务监听端口：netstat -lnp 8. 防火墙：iptables, SELinux 总之与本文的思路是非常一致的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux服务器性能检测-I/O篇]]></title>
      <url>%2F2017%2F01%2F03%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B-I-O%E7%AF%87%2F</url>
      <content type="text"><![CDATA[当磁盘无法写入的时候，一般有以下可能: 文件系统只读 磁盘已满 I节点使用完 只读的文件系统文件系统自动设置成只读可能是系统自我保护的一种机制，因此需要实现弄清究竟什么原因造成了文件系统的只读。如果想要改变文件系统的只读属性，重新挂载目标分区即可。例1. 重新挂载改变/home分区的读写属性 #mount -o remount, rw /home -o 选项后面接了两个mount命令的专有选项，remount 是指重新挂载指定文件系统，rw指定重新挂载时的读写属性，该命令不改变挂载点，只是改变制定分区的读写属性。 磁盘满磁盘使用率、剩余空间等可以使用df命令查看例2. 查看当前已挂载的所有分区及使用情况 # df -h Filesystem Size Used Avail Use% Mounted on /dev/sda2 133G 8.6G 118G 7% / none 4.0K 0 4.0K 0% /sys/fs/cgroup udev 5.9G 4.0K 5.9G 1% /dev tmpfs 1.2G 868K 1.2G 1% /run none 5.0M 0 5.0M 0% /run/lock none 5.9G 0 5.9G 0% /run/shm none 100M 0 100M 0% /run/user /dev/sda1 93M 3.4M 90M 4% /boot/efi -h 自动以适合阅读的单位显示，该例子的磁盘空间显然还很充分。有时候会发现，df结果中的使用空间”Used”和容量”Size”存在一定的差距，但是可用空间”Avail”却所剩无几，同时使用率”Use %”居高不下，甚至达到100%。这种情况并不奇怪，因为Linux为了避免系统存储空间完全占用导致的root用户无法登陆，为root用户保留了一块保留区块，供磁盘使用率过高时root用户登录系统完成必要的清理操作。仅有root用户可以在这些保留块中写入数据，可以通过tune2fs工具查看保留块的大小。例3. 使用tune2fs查看系统保留块 # tune2fs -l /dev/xvda1 | grep -i &quot;block&quot; Block count: 16776704 Reserved block count: 838832 Free blocks: 15870165 First block: 0 Block size: 4096 Reserved GDT blocks: 1020 Blocks per group: 32768 Inode blocks per group: 512 Flex block group size: 16 Reserved blocks uid: 0 (user root) Reserved blocks gid: 0 (group root) Journal backup: inode blocks 其中，第3行显示系统保留块的数量，第6行显示每块的大小(4KB)，二者相乘可以计算保留块的总大小第11、12行显示能对保留区块执行写入操作的用户和用户组编号，这里都是root;上面只是查看某个文件系统上所有目录的大小。例4. 使用du查看目录占用的空间 # cd / # du -ckx | sort -n &gt; /tmp/dir_space 使用tail查看保存的/tmp/dir_space文件可以看到根文件系统下最大的10个目录: 674236 ./var/log 904232 ./usr/lib 1372776 ./var/lib/glance/images 1372868 ./var/lib/glance 1523512 ./var/lib/mongodb 2082052 ./usr 4003024 ./var/lib 4878944 ./var 8798036 . 8798036 total 这里可以看到/var/log目录是很大的，由于/var/log目录存放的是一些日志文件，日志文件通常也是占用系统空间的源泉，可以通过释放日志文件空间来获得存储空间: # ls -lhs /var/log/syslog.1 1.3M -rw-r----- 1 syslog adm 1.3M Aug 12 06:34 syslog.1 # bash -c &quot;&gt; /var/log/syslog.1&quot; # ls -lhs /var/log/syslog.1 0 -rw-r----- 1 syslog adm 0 Aug 12 15:16 syslog.1 该例子将分卷后的syslog文件截断，实际上就是删除指定日志文件的内容。当然也可以直接删除对应的日志文件。 I节点不足当df显示磁盘空间充足，但是文件系统却报错自己已满，无法写入时，需要检查是否耗尽了I节点。在系统中创建一个新文件将会获得一个唯一的I节点，就无法再创建新的文件了，这在系统创建大量文件时才有可能发生。使用df -i命令可以查看I节点的使用情况。例5. 查看I节点的使用情况 # df -i Filesystem Inodes IUsed IFree IUse% Mounted on udev 503145 424 502721 1% /dev tmpfs 505857 335 505522 1% /run /dev/xvda1 4194304 130790 4063514 4% / none 505857 2 505855 1% /sys/fs/cgroup none 505857 3 505854 1% /run/lock none 505857 1 505856 1% /run/shm none 505857 2 505855 1% /run/user 可以看到当前各个文件系统的I节点充足。一旦遇到I节点用光的情形，有以下几种选择: 删除大量文件 将大量文件移动到其他的文件系统中 将大量的文件压缩成一个文件 备份当前文件系统中的所有文件，重新格式化之前的磁盘，获取更多的I节点，再将文件复制回去。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux服务器性能检测-CPU负载篇]]></title>
      <url>%2F2016%2F12%2F30%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B-CPU%E8%B4%9F%E8%BD%BD%E7%AF%87%2F</url>
      <content type="text"><![CDATA[查看系统负载查看系统负载的工具: uptime、w 等。系统平均负载时处于运行或不可打扰状态的进程的平均数 * 可运行: 运行态，占用CPU，或就绪态，等待CPU调度 * 不可打扰: 阻塞，正在等待I/O 例1. 使用uptime查看系统负载 # uptime 19:26:17 up 49 days, 7:34, 1 user, load average: 0.67, 0.51, 0.41 这里我们关注的是最后三列，即系统1分钟、5分钟、15分钟内的平均负载，判断一个系统负载是否偏高需要计算单核CPU的平均负载，等于这里uptime命令显示的系统平均负载 / CPU核数，一般以0.7为比较合适的值。偏高说明有比较多的进程在等待使用CPU资源。 例2. 使用w查看系统负载 # w 19:29:47 up 49 days, 7:38, 1 user, load average: 0.42, 0.46, 0.41 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT openstac pts/1 10.14.16.25 19:21 1.00s 0.19s 0.03s sshd: openstack [priv] 使用 w 命令也可以查看类似的信息，w 命令还提供了当前登录用户，以及正在执行的操作等信息。系统负载可以是CPU密集型的，也可以是RAM密集型和I/O密集型的，CPU密集型的系统比I/O密集型的系统响应度更好，因为I/O密集型的系统的磁盘I/O可能完全饱和，导致登录就很费事。 top 命令top命令不仅可以查看当前系统的平均负载，还可以查看不同进程对于CPU、内存等资源的使用情况，在内存排障部分我们也将介绍top命令。例3.使用top命令查看CPU使用率 默认情况下，top命令是以CPU使用率由高到低排序显示进程信息的，在 top 信息界面按 K 键，并输入想要终止的PID，就可以直接杀死指定进程。 top的 -b 选项开启批处理模式，将每次刷新全部打印到stdouttop的 -n 选项指定退出top命令前刷新多少次信息。top命令的输出： 第1行：与uptime相同； 第3行：当前的CPU运行情况： us：非nice用户进程占用CPU的比率 sy：内核、内核进程占用CPU的比率； ni：如果一些用户进程修改过优先级，这里显示这些进程占用CPU时间的比率； id：CPU空闲比率，如果系统缓慢而这个值很高，说明系统慢的原因不是CPU负载高； wa：CPU等待执行I/O操作的时间比率，该指标可以用来排查磁盘I/O的问题，通常结合wa和id判断 hi：CPU处理硬件终端所占时间的比率； si：CPU处理软件终端所占时间的比率； st：流逝的时间，虚拟机中的其他任务所占CPU时间的比率； 用户进程占比高，wa低，说明系统缓慢的原因在于进程占用大量CPU，通常还会伴有教低的id，说明CPU空转时间很少； wa低，id高，可以排除CPU资源瓶颈的可能。 wa高，说明I/O占用了大量的CPU时间，需要检查交换空间的使用，交换空间位于磁盘上，性能远低于内存，当内存耗尽开始使用交换空间时，将会给性能带来严重影响，所以对于性能要求较高的服务器，一般建议关闭交换空间。另一方面，如果内存充足，但wa很高，说明需要检查哪个进程占用了大量的I/O资源。 iostat 命令iostat 命令可以查看系统分区的IO使用情况例4.iostat命令查看IO占用 1 wgfxcu@Ubos:~$ iostat 2 Linux 3.13.0-24-generic (Ubos) 2016年12月30日 _x86_64_ (1 CPU) 3 4 avg-cpu: %user %nice %system %iowait %steal %idle 5 0.22 0.01 0.55 0.04 0.00 99.17 6 Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn 7 scd0 0.00 0.00 0.00 48 0 8 sda 0.32 2.67 4.12 765668 1182218 9 dm-0 0.54 2.66 4.12 762573 1182212 10 dm-1 0.00 0.00 0.00 896 0 在第2行系统发行版本下面的第4、5行，可以看到与top命令中CPU使用情况类似的信息，第7行，可以看到一些IO指标： tps: 每秒I/O传输请求量； kB_read/s：每秒读取多少KB； kB_wrtn/s：每秒写多少KB； kB_read：一共读了多少KB； kB_wrtn：一共写了多少KB。 iostat命令属于sysstat工具包，由于我们的机器只挂载了一块硬盘，因此不能体现不同设备的I/O区别。 iotop 命令iotop命令类似于top命令，但是现实的是各个进程的I/O情况，对于定位I/O操作较重的进程有比较大的作用。例5. iotop命令与进程的IO状况 sysstat工具与负载历史回放很多系统负载过高的时候我们是无法立即获知或者立即解决的，当检测到或者知道历史的高负载状况时，可能需要回放历史监控数据，这时 sar 命令就派上用场了，sar命令同样来自sysstat工具包，可以记录系统的CPU负载、I/O状况和内存使用记录，便于历史数据的回放。Ubuntu系统上，sysstat的配置文件在/etc/default/sysstat，sysstat默认关闭，通过将该文件中的ENABLED改为”true”启用；历史日志的存放位置为/var/log/sysstatRed Hat系统上，sysstat的配置文件在/etc/sysconfig/sysstat文件，历史日志的存放位置为/var/log/sa两种系统上，统计信息都是每10分钟记录一次，每天的23:59会分割统计文件，这些操作的频率都在/etc/cron.d/sysstat文件配置。 sar命令查看CPU、内存和磁盘记录默认情况下，sar命令显示当天的统计信息，不带参数显示CPU统计信息，参数-r显示收集的内存记录，-b显示磁盘I/O例6. 使用sar命令查看CPU使用 # sar Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 12:00:01 AM CPU %user %nice %system %iowait %steal %idle 12:05:01 AM all 3.83 0.02 4.24 0.61 0.00 91.30 12:15:01 AM all 3.57 0.02 4.28 0.58 0.00 91.54 12:25:01 AM all 3.83 0.02 5.16 0.60 0.00 90.39 12:35:01 AM all 3.98 0.02 5.66 0.58 0.00 89.76 12:45:01 AM all 3.86 0.02 5.26 0.59 0.00 90.28 12:55:01 AM all 3.77 0.02 5.19 0.60 0.00 90.42 例7. 使用sar命令查看当天内存使用 # sar -r Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 12:00:01 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 12:05:01 AM 6420736 5839392 47.63 242640 1366912 6811944 55.56 4324000 1202152 24 12:15:01 AM 6423128 5837000 47.61 242640 1367348 6830944 55.72 4320608 1202400 48 12:25:01 AM 6430984 5829144 47.55 242640 1367548 6814980 55.59 4314376 1202468 48 12:35:01 AM 6422924 5837204 47.61 242640 1367848 6817224 55.60 4321604 1202576 48 12:45:01 AM 6427300 5832828 47.58 242640 1368056 6822240 55.65 4318412 1202572 28 例8. 使用sar命令查看当天IO统计记录 # sar -b Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 12:00:01 AM tps rtps wtps bread/s bwrtn/s 12:05:01 AM 7.44 0.00 7.44 0.00 279.22 12:15:01 AM 6.45 0.00 6.45 0.00 255.84 12:25:01 AM 6.59 0.00 6.59 0.00 260.20 12:35:01 AM 6.51 0.00 6.51 0.00 261.42 12:45:01 AM 6.42 0.00 6.42 0.00 255.79 使用sar查看指定时间、制定日期的历史记录例9. 使用参数-s和-e先定查看的时间 # sar -s 20:00:00 Linux 3.13.0-55-generic (ISeR-Server1) 08/12/2015 _x86_64_ (4 CPU) 08:05:01 PM CPU %user %nice %system %iowait %steal %idle 08:15:01 PM all 3.98 0.02 6.07 0.58 0.00 89.34 08:25:01 PM all 4.32 0.02 5.74 0.58 0.00 89.34 Average: all 4.15 0.02 5.91 0.58 0.00 89.34 例10. 使用参数-f查看本月内之前某一天的历史统计信息 # sar -f /var/log/sysstat/sa08 Linux 3.13.0-55-generic (ISeR-Server1) 08/08/2015 _x86_64_ (4 CPU) 12:00:01 AM CPU %user %nice %system %iowait %steal %idle 12:05:01 AM all 3.65 0.02 2.79 0.60 0.00 92.94 12:15:01 AM all 3.45 0.02 3.03 0.56 0.00 92.94 12:25:01 AM all 3.43 0.02 3.25 0.56 0.00 92.74 12:35:01 AM all 3.44 0.01 3.09 0.56 0.00 92.89 12:45:01 AM all 3.25 0.02 1.35 0.55 0.00 94.83 12:55:01 AM all 3.36 0.02 1.77 0.56 0.00 94.29 sysstat工具只存储1个月内的系统使用记录，每天的记录以saN为文件名保存在相应的日志目录中，这里我们查看本月8号的CPU使用记录。 CPU占高排查使用top命令查看占比高的进程 用top -H -p pid命令查看进程内各个线程占用的CPU百分比 查看进程中各线程的函数调用栈 使用pstack pid 查看进程中各县城的函数调用栈 使用gdb 可以使用gcore命令转存进程映像及内存上下文: #gcore 14094 该命令生成core文件core.14094 然后使用gdb调试core文件，使用info threads 查看具体的所有线程，thread –切换到threadno的线程，使用bt命令可以查看当前线程的函数调用栈 也可以使用gdb 然后attach pid ，然后再使用 thread apply all bt 查看所有线程的函数调用栈。 用strace命令查看系统调用和花费的时间 #strace -T -r -c -p pid -c 参数显示统计信息，去掉此参数可以查看每隔系统调用花费的时间及返回值 总结处理CPU占比高的流程: 进程ID-&gt;线程ID-&gt;线程函数调用栈-&gt;函数耗时和调用统计-&gt;源代码分析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux服务器性能检测-内存篇]]></title>
      <url>%2F2016%2F12%2F30%2FLinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B-%E5%86%85%E5%AD%98%E7%AF%87%2F</url>
      <content type="text"><![CDATA[事实上，当上述服务器系统资源中的任何一个遭遇瓶颈，都会带来服务器性能的下降，典型的症状就是系统运行迟缓。本文从以下几个角度介绍Linux系统内存相关的排查。 内存的使用率如何查看，使用率真的很高吗 内存用在哪里了 内存优化可以有哪些手段 内存硬件查看在Linux系统环境下，可以使用dmidecode命令查看硬件设备的详细信息。命令格式: dmidecode -t typecode其中typecode是设备类型代码， 具体代码如下： 0 BIOS 1 System 2 Base Board 3 Chassis 4 Processor 5 Memory Controller 6 Memory Module 7 Cache 8 Port Connector 9 System Slots 10 On Board Devices 11 OEM Strings 12 System Configuration Options 13 BIOS Language 14 Group Associations 15 System Event Log 16 Physical Memory Array 17 Memory Device 18 32-bit Memory Error 19 Memory Array Mapped Address 20 Memory Device Mapped Address 21 Built-in Pointing Device 22 Portable Battery 23 System Reset 24 Hardware Security 25 System Power Controls 26 Voltage Probe 27 Cooling Device 28 Temperature Probe 29 Electrical Current Probe 30 Out-of-band Remote Access 31 Boot Integrity Services 32 System Boot 33 64-bit Memory Error 34 Management Device 35 Management Device Component 36 Management Device Threshold Data 37 Memory Channel 38 IPMI Device 39 Power Supply 例如： 使用dmidecode -t 1 可以查看主板信息(制造商、型号、序列号等等) 使用dmidecode -t 4 可以查看CPU信息(CPU数据、型号、大小、频率等等) 使用dmidecode -t 17 可以查看内存信息(插槽数目、内存类型、大小、频率等等) 通过dmidecode工具可以查看很多硬件相关的数据，这里仅以内存为例。我们可以看到，服务器最大支持内存扩充为4GB，目前已经安装了4GB内存。 内存的使用情况使用free命令可以查看内存的使用情况。-m以MB为单位显示整个系统的使用情况: -h则自动选择以适合理解的容量单位显示: 可以看到系统内存4G(总可用3.9G)，当前医用3.8G，剩余103M。命令显示的”used”的值很高，接近total的值了，那么系统就真的没有内存空间了吗？我们可以看到free命令下面有一行“-/+ buffers/cache”，该行显示的used是上一行“used”的值减去buffers和cached的值，同时该行的free是上一行的free加上buffers和cached的值。这里可以看到，尽管第一行的used显示共使用了3.8GB的物理内存，但除去buffers和cached数据后，实际仅仅占用了631M的内存，而如果剩余空间加上buffers和cached数据当前占用的内存，将达到3.2BG。这是因为buffers和cache数据是动态变化的，内存充足时，内核出于性能考虑会进行一定的缓存，当内存空间不足时，buffers, cached占用的空间是可以为了程序释放的。因此判断系统内存是否耗竭的实际指标是看减去buffer和cache的空间后used空间是否依旧很大，以及交换空间是否被大量占用。显然这个例子不符合内存耗竭的情形。 查看消耗内存较多的内存top 命令用来查看具体进程消耗的内存空间 top 命令查看系统的实时负载，包括进程、CPU负载、内存使用等等；进入top的实时界面后，默认按照CPU的使用率排序，通过”shift+m”将进程按照内存使用情况排序，可以查看哪些进程是当前系统的内存开销”大户”。top 命令中，按下f键，进入选择排序的界面，可以选择要显示的信息列，要按照哪些信息列进行排序等，该界面上有简要的介绍。另一方面，我们查看不同进程的内存开销: 通过%MEM列，可以查看哪几个进程占用了大量的内存，在缓解内存不足的紧急情况时，可以终止这些占用内存较多的进程。top 命令中有一下与内存相关的数据列: （1）VIRT:虚拟内存，是进程身亲的虚拟内存总量。 （2）RES: 常驻内存，是进程切实使用的物理内存量，free命令中看到的used列下面的值，就包括常驻内存的和，但不是虚拟内存的和。 （3）SHR: 共享内存，比如共享占用的内存等。 交换空间使用free 命令可以查看内存的总体使用，显示的内容也包括交换分区的大小，使用swapon、swapoff命令开启或关闭交换空间，交换空间是磁盘上的文件，并不是真正的内存空间。当内存不足时，系统会选择通过: 1.将部分不常被访问的内存页交换到内存空间; 2.删除部分cache 的文件来释放内存空间。系统的可用内存一般等于物理内存+交换分区。交换分区在磁盘上，因此速度比内存读写要慢的多。交换分区实际上就是磁盘上的文件，可以通过mkswap 命令创建交换空间。 内核态内存占用slab系统用来处理系统中比较小的元数据，如文件描述符等，进而组织内核态的内存分配。一个slab包含多个object,例如dentry这些数据结构就是object,可以通过slabtop命令查看系统中活动的object的数量与内存占用情况，从而了解哪些数据结构最占用内核态的内存空间。例如: 使用slabtop 命令查看内核数据结构及内存占用 关注点: 1. 哪些数据结构的内存占用最大 2. 哪些类型的数据结构对应的object最多，比如inode多代表文件系统被大量引用等。 该交互命令支持的选项与排序标准有:选项： --delay=n, -d n 每隔n秒刷新信息 --once, -o 只显示一次 --sort=S, -s S 按照S排序，其中S为排序标准 排序标准(shift + 对应的键)： a：根据active objects数量高低排序 b：根据 objects / slab高低来排序 c：根据cache大小排序 l：根据slab数量排序 v：根据active slabs数量排序 n：按 name 排序 o：按照 objects 数量排序 p：按照 pages / slab 的值排序 s：按照 object 大小排序 u：按照 cache 使用量排序 查看内存使用的动态变化vmstat命令可以查看内存使用的动态变化 每行会输出一些系统核心指标，这些指标可以让我们更详细的了解系统状态。后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义，这几介绍一些和性能调优相关的列： r：等待CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。 free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。 si, so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。 us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。 dstatdstat命令是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具。与sysstat相比，dstat拥有一个彩色的界面，在手动观察性能状况时，数据比较显眼容易观察；而且dstat支持即时刷新，譬如输入dstat 3即每三秒收集一次，但最新的数据都会每秒刷新显示。和sysstat相同的是，dstat也可以收集指定的性能资源，譬如dstat -c即显示CPU的使用情况。 查看共享内存空间pmap 命令用于报告进程的内存映射关系，是Linux调试及运维一个很好的工具。常用选项: -x: 显示扩展格式 -d: 显示设备格式 -q: 不显示头尾行 -V: 显示指定版本 参数: 进程号: 制定需要显示内存映射关系的进程号，可以是多个进程号 查看系统内存历史记录sar(System Activity Reporter系统活动情况报告) 是目前Linux上最为全面的系统性能分析工具之一。可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。命令格式: sar [options] [-A] [-o file] t [n] 其中: t 为采样间隔，n为采样次数，默认值是1 -o file 表示将命令结果以二进制格式存放在文件中，file是文件名 options 为命令行选项，命令常用选项: -A: 所有报告的总和 -u: 输出CPU使用情况的统计信息 -v: 输出inode、文件和其他内核表的统计信息 -d: 输出每一块设备的活动信息 -r: 输出内存和交换空间的统计信息 -b: 显示I/O和传送速率的统计信息 -a: 文件读写情况 -c: 输出进程统计信息,每秒创建的进程数 -R: 输出内存页面的统计信息 -y: 终端设备活动情况 -w: 输出系统交换活动信息 如何清理内存使用 释放占用的缓存空间 # sync //先将内存刷出，避免数据丢失 # echo 1 &gt; /proc/sys/vm/drop_caches //释放pagecache # echo 2 &gt; /proc/sys/vm/drop_caches //释放dentry和inode # echo 3 &gt; /proc/sys/vm/drop_caches //释放pagecache、dentry和inode 终止进程 与Linux内存相关的文件系统文件内存信息: /proc/meminfo进程状态信息: /proc/$pid/status进程物理内存信息: /proc/$pid/statmslab的分布情况: /proc/slabinfo虚拟内存信息: /proc/vmstat 小福利 降低swap的使用率: # sysctl -a | grep swappiness vm.swappiness = 60 限制其他用户的内存使用: # vim /etc/security/limits.conf user1 hard as 1000 （用户user1所有累加起来，内存不超过1000kiB） user1 soft as 800 （用户user1一次运行，内存不超过800kiB） 大量连续内存数据: # vim /etc/sysctl.conf vm.nr_hugepage=20 调节page cache(大量一样的请求 调大page cache) vm.lowmem_reserve_ratio = 256 256 32 （保留多少内存作为pagecache 当前 最大 最小） vm.vfs_cache_pressure=100 （大于100，回收pagecache） vm.page.cluster=3（一次性从swap写入内存的量为2的3次方页） vm.zone_reclaim_mode=0/1（当内存危机时，是否尽量回收内存 0:尽量回收 1:尽量不回收） min_free_kbytes：该文件表示强制Linux VM最低保留多少空闲内存（Kbytes）。 脏页 vm.dirty_background_radio=10 （当脏页占内存10%，pdflush工作） vm.dirty_radio=40 （当进程自身脏页占内存40%，进程自己处理脏页，将其写入磁盘） vm.dirty_expire_centisecs=3000 （脏页老化时间为30秒 3000/100=30秒） vm.dirty_writeback_centisecs=500 （每隔5秒，pdflush监控一次内存数量 500/100=5秒）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建GitHub博客（三）- NexT主题配置使用]]></title>
      <url>%2F2016%2F12%2F07%2FNexT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[NexT是一款简洁优雅且易于使用的主题，配置比较简单，只需要稍微修改配置文件即可，功能也比较全，分类、归档、标签显示明了，让人一看就知道干嘛的。 NexT主题官方文档还算详细，但是有些部分的介绍不够详细，这里我做部分补充，并对自己做了修改的部分作介绍。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 安装 NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码 $ cd your-hexo-site $ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 主题设定选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可。 设置 语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 设置 菜单NexT主题菜单设置，用于设置博客上方导航栏，在 主题配置文件 中修改。 menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 只是在menu选项中设置还不能让标签页面、分类页面生效，需要我们手动创建 标签页面1&gt;运行以下命令 hexo new page &quot;tags&quot; 同时，在/source目录下会生成一个tags文件夹，里面包含一个index.md文件 2&gt;修改/source/tags目录下的index.md文件 title: tags date: 2015-09-29 14:37:02 type: &quot;tags&quot; --- 3&gt;修改主题配置文件去掉tags的注释 menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 分类页面1&gt;运行以下命令 hexo new page &quot;categories&quot; 同时，在/source目录下会生成一个categories文件夹，里面包含一个index.md文件 2&gt;修改/source/categories目录下的index.md文件 title: categories date: 2015-09-29 14:47:21 type: &quot;categories&quot; --- 3&gt;修改主题配置文件去掉categories的注释 menu: home: / #主页 categories: /categories #分类页（需手动创建） #about: /about #关于页面（需手动创建） archives: /archives #归档页 tags: /tags #标签页（需手动创建） #commonweal: /404.html #公益 404 （需手动创建） 设置侧栏默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值 设置侧栏显示的时机，修改 sidebar.display 的值 侧边头像设置在next主题文件夹中的 source 目录中，创建 uploads 目录，将你的头像avatar.png放入该目录下。编辑 站点配置文件，增加avatar字段 # Avatar avatar: /uploads/avatar.png 设置作者昵称编辑 站点配置文件， 设置 author 为你的昵称。 站点描述编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 多说评论多说站点使用多说前需要先在 多说 创建一个站点。具体步骤如下： 登录后在首页选择 “我要安装”。 创建站点，填写站点相关信息。 多说域名 这一栏填写的即是你的 duoshuo_shortname，如图： 创建站点完成后在 主题配置文件 中duoshuo_shortname 字段的值设置成上一步中的值。 12# Duoshuo ShortName duoshuo_shortname: wgfxcu 至此，当你重新访问你的博客时，在每篇博文后面就会有多说的评论框。但是，你会发现在分类页和标签页也会看到评论框，如果你感觉不爽可以通过下面的方法去掉。 去除分类页标签页多说评论修改站点的/source/categories/目录下的 index.md 文件 --- title: categories date: 2016-12-06 15:58:52 type: &quot;categories&quot; comments: false #去除多说评论框 --- 同样修改站点的/source/tags/目录下的index.md文件即可去掉标签页的评论框. 数据统计与分析官方提供的 数据统计与分析 配置了一下，感觉影响主题的整体美观，所以放弃了。如果有需要可以参考官网文档设置一下。 内容分享服务官方提供的 内容分享服务 配置了一下，感觉影响主题的整体美观，所以放弃了。如果有需要可以参考官网文档设置一下。 搜索服务官方提供的 搜索服务 有兴趣的可以折腾一下。 至此，我们的博客就搭建完成了。O(∩_∩)O哈哈~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建GitHub博客（二）- Hexo配置使用]]></title>
      <url>%2F2016%2F12%2F07%2FHexo%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[这篇博文主要介绍Hexo的配置安装和Hexo的常用命令，还有如何部署博客到GitHub。 Hexo 安装打开Git命令行，执行如下命令 $ npm install -g hexo 初始化博客安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init blog$ cd blog$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml1网站的配置信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 123456789101112131415161718192021222324package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.2.2&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-searchdb&quot;: &quot;^1.0.3&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-migrator-rss&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot;, &quot;hexo-toc&quot;: &quot;^1.0.4&quot; &#125;&#125; scaffolds模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题文件夹。Hexo 会根据主题来生成静态页面。 配置您可以在 _config.yml 中修改大部份的配置。 网站 网址 网站存放在子目录 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 文章 分类 &amp; 标签 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 分页 扩展 Hexo 指令init$ hexo init [folder] 新建一个网站。如果没有设置 folder，Hexo 默认在目前的文件夹建立网站。 new$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate$ hexo generate 生成静态文件。 publish$ hexo publish [layout] &lt;filename&gt; 发表草稿。 server$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 deploy$ hexo deploy 部署网站。 render$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 migrate$ hexo migrate &lt;type&gt; 从其他博客系统迁移内容。 clean$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 list$ hexo list &lt;type&gt; 列出网站资料。 version$ hexo version 显示 Hexo 版本。 选项安全模式$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式$ hexo --silent 隐藏终端信息。 自定义配置文件的路径$ hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。 测试启动Server运行以下命令 $ hexo server Hexo server启动后，在浏览器中打开http://localhost:4000/ 即可访问自己的博客，按Ctrl+C停止 创建文章运行以下命令，可生成一篇文章，刷新http://localhost:4000/ 即可看到新生成的文章。 $ hexo new &quot;hello-hexo&quot; 同时在/blog/source/_posts目录下会生成一个”hello-hexo.md”的markdown文件，可以使用一个支持markdown语法的编辑器来编辑该文件，刷新http://localhost:4000/ 即可看到修改后的结果。 打开这个文件 生成静态网页运行以下命令，将markdown文件生成静态网页。 $ hexo generate 同时在/blog/目录下会生成一个public文件夹，里面是生成的静态文件。 部署到GitHub至此我们已经可以在本地访问自己的博客了，但是只有本地能够看到，要部署到GitHub上面别人才能看到。我们可以在本地调试编辑好文章后再推送到GitHub上面。下面是部署到GitHub的过程。 创建github page在第一篇文章中我们已经在自己的github中创建了自己的github page。参考Hexo搭建GitHub博客（一）- 环境搭建 安装自动部署到GitHub的插件在初始化博客的时候运行的npm install命令默认并没有安装这个插件，所以要手动安装。运行以下命令 $ npm install hexo-deployer-git 修改站点配置文件 修改位于 blog 目录下的 _config.yml 文件找到以下内容 repository是自己github page的项目地址 运行hexo deploy命令运行以下命令 $ hexo deploy 过程中会提示输入你的github账号和密码，等待命令运行完成即可。部署完成后，在浏览器中访问wgfxcu.github.io能够看到你在本地调试好的博客，表示部署成功！ 部署步骤总结至此，部署到GitHub的工作已经完成，之后如果我们希望对自己的博客进行修改或者需要发布新的文章时，可以按以下三步进行。123$ hexo clean # 删除已经生成的静态页面 $ hexo generate $ hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建GitHub博客（一）- 环境搭建]]></title>
      <url>%2F2016%2F12%2F05%2FHexo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[前言之前无意中发现conglang的github博客，简洁干净，符合我的style。后来发现他使用HEXO+GitHub+Next主题搭建的。按耐不住就索性自己也来一个。同时也记录一下自己的实现过程，做个备案。 推荐理由: 免费：github提供gh-pages服务是免费的，有300MB空间； 开源：由于github开源的原因，有很多人参与其中，自然技术支持很好。 便捷：博客完全托管在github上，基本上不需要花时间去管理，博客使用Markdown语法，上手很容易。 需要了解的内容（能掌握更好）： html+css+javascript git基本语法 markdown语法 nodejs 说明：本次搭建的环境是：Ubuntu14.04 安装 Git安装 Git 客户端 安装 Git 客户端 下载地址 安装Git客户端：Windows用户直接Next就可以了。Mac和Linxu系统的用户可通过命令方式安装，这里不详细介绍了。 附上廖雪峰的Git经典入门教程: Git入门教程 注册 GitHub 老手和已注册过的用户略 打开GitHub官网：https://github.com/ 填写注册信息进行注册操作：没有登录的用户打开网站首页就会显示注册的操作（如图所示），或者是点击Sign up按钮进入注册详情页。 填写好注册信息，点击Sign up for GitHub(注册)按钮后，接下来是选择协议部分。根据自己的情况选择相关的协议，一般人选的都是免费的那一项。 创建仓库 登录github账号：在github首页点击Sign in按钮进入登录页面。填写用户名或邮箱和密码，点击Sign in按钮登录。 点击创建仓库：点击在登录的用户图像左边的+号和下三角符号按钮。 填写创建仓库信息：仓库名称必须是用户名.github.io（别问我为什么，人家就是这样规定的），比如我的用户名是wgfxcu，就是wgfxcu.github.io。 填写好相关信息，点击Create repository(创建仓库)按钮。 配置 SSH 老手和已注册过的用户略 打开Git Bash终端：在桌面右键，会出现”Git Bash here”的选项，点击即可。 设置user name和email： $ git config --global user.name &quot;你的GitHub用户名&quot; $ git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥:输入下面命令 $ ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 一般情况下是不需要密码的，所以，接下来直接回车就好。 此时，在用户文件夹下就会有一个新的文件夹.ssh，里面有刚刚创建的ssh密钥文件id_rsa和id_rsa.pub。 注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件. 添加公钥到github： 点击用户头像，然后点击显示的Settings(设置)选项； 在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key(新建SSH)按钮； 将id_rsa.pub中的内容复制到Key文本框中，然后点击Add SSH key(添加SSH)按钮； 测试 SSH: $ ssh -T git@github.com 接下来会出来下面的确认信息： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 17:24:ac:a5:76:28:24:36:62:1b:36:4d:eb:df:a6:45. Are you sure you want to continue connecting (yeso)? 输入yes后回车。 然后显示如下信息则OK(其中的SeayXu是用户名)。 Hi wgfxcu! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 搭建 Node.js 开发环境本次没有使用ubuntu自带的nodejs版本，实在是版本太低。也没有使用源码进行安装，实在是太麻烦。根据Hexo官方文档使用nvm管理和安装Node.js。nvm 的全称是 Node Version Manager，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。 安装 nvmcURL: $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 脚本下载nvm仓库下载到 ~/.nvm , 同时在你的配置文件中添加源代码行 (~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc)。 export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 如果你在shell命令行中输入nvm，得到的是 nvm: command not found。你需要在命令行中执行以下命令： source ~/.bashrc 安装切换各版本 node/npmnvm install stable #安装最新稳定版 node，现在是 v7.2.0 nvm install 6.0.0 #安装 6.0.0 版本 nvm install 0.12.7 #安装 0.12.7 版本 # 特别说明：以下模块安装仅供演示说明，并非必须安装模块 nvm use 0 #切换至 0.12.7 版本 nvm use 6 #切换至 6.0.0 版本 nvm alias default 7.2.0 #设置默认 node 版本为 7.2.0 这时候可以看到自己安装的所有 Node.js 版本，输出应如下： 使用 .nvmrc 文件配置项目所使用的 node 版本如果你的默认 node 版本（通过 nvm alias 命令设置的）与项目所需的版本不同，则可在项目根目录或其任意父级目录中创建 .nvmrc 文件，在文件中指定使用的 node 版本号，例如： cd &lt;项目根目录&gt; #进入项目根目录 echo 7 &gt; .nvmrc #添加 .nvmrc 文件 nvm use #无需指定版本号，会自动使用 .nvmrc 文件中配置的版本 node -v #查看 node 是否切换为对应版本 nvm 与 n 的区别node 版本管理工具还有一个是 TJ 大神的 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。 由于 npm 安装的模块路径均为 /usr/local/lib/node_modules ，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。 因此建议各位尽早开始使用 nvm ，以免出现全局模块无法更新的问题。关于 nvm 和 n 详细区别可以参考淘宝前端团队(FED)博客。 ###]]></content>
    </entry>

    
  
  
</search>
